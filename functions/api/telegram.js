import { LotteryDB } from \'../db/d1-database.js\';\nimport { generatePrediction } from \'../logic/prediction.js\'; // å¼•å…¥æ–°çš„é¢„æµ‹å¼•æ“Ž\nimport { getSpecialNumber, getZodiac, getWave } from \'../logic/utils.js\';\n\nconst MAIN_KEYBOARD = [[{ text: \'ðŸ”„ åŒæ­¥æ•°æ®\' }, { text: \'ðŸ—‚ï¸ æŸ¥çœ‹è®°å½•\' }], [{ text: \'ðŸ”® æ‰§è¡Œé¢„æµ‹\' }]];\nconst LOTTERY_TYPES = { \'HK\': \'é¦™æ¸¯\', \'XINAO\': \'æ–°æ¾³\', \'LAOAO\': \'è€æ¾³\', \'LAOAO_2230\': \'è€æ¾³22:30\' };\nconst WAVE_MAP = {\n    \'red\': \'çº¢æ³¢\', \'blue\': \'è“æ³¢\', \'green\': \'ç»¿æ³¢\',\n    \'çº¢\': \'çº¢æ³¢\', \'è“\': \'è“æ³¢\', \'ç»¿\': \'ç»¿æ³¢\'\n};\n\nclass Bot {\n    constructor(token) { this.token = token; }\n    async apiCall(methodName, payload) {\n        const url = `https://api.telegram.org/bot${this.token}/${methodName}`;\n        const res = await fetch(url, { method: \'POST\', headers: { \'Content-Type\': \'application/json\' }, body: JSON.stringify(payload) });\n        return res.json();\n    }\n    sendMessage(chatId, text, markup = null) { return this.apiCall(\'sendMessage\', { chat_id: chatId, text, reply_markup: markup, parse_mode: \'Markdown\' }); }\n    editMessageText(chatId, msgId, text) { return this.apiCall(\'editMessageText\', { chat_id: chatId, message_id: msgId, text, parse_mode: \'Markdown\' }); }\n    deleteMessage(chatId, msgId) { return this.apiCall(\'deleteMessage\', { chat_id: chatId, message_id: msgId }); }\n    answerCallback(id) { return this.apiCall(\'answerCallbackQuery\', { callback_query_id: id }); }\n}\n\nexport const onRequestPost = async ({ request, env }) => {\n    const payload = await request.json();\n    const chatId = payload.message?.chat.id || payload.callback_query?.message.chat.id;\n    if (!chatId || chatId.toString() !== env.TELEGRAM_ADMIN_ID) return new Response(\'Unauthorized\', { status: 401 });\n\n    const context = { db: new LotteryDB(env.DB), bot: new Bot(env.TELEGRAM_BOT_TOKEN), env, payload };\n    if (payload.message?.text) await handleTextMessage(context);\n    else if (payload.callback_query) await handleCallbackQuery(context);\n    return new Response(\'OK\');\n};\n\nasync function handleTextMessage(ctx) {\n    const text = ctx.payload.message.text.trim();\n    if (text === \'/start\') await ctx.bot.sendMessage(ctx.payload.message.chat.id, \'æ‚¨å¥½ï¼è¯·é€‰æ‹©ï¼š\', { keyboard: MAIN_KEYBOARD, resize_keyboard: true });\n    else if (text.includes(\'åŒæ­¥\')) await sendLotterySelection(ctx.bot, ctx.payload.message.chat.id, \'sync\', \'è¯·é€‰æ‹©åŒæ­¥ç±»åž‹ï¼š\');\n    else if (text.includes(\'æŸ¥çœ‹\')) await sendLotterySelection(ctx.bot, ctx.payload.message.chat.id, \'view\', \'è¯·é€‰æ‹©æŸ¥çœ‹ç±»åž‹ï¼š\');\n    else if (text.includes(\'é¢„æµ‹\')) await sendLotterySelection(ctx.bot, ctx.payload.message.chat.id, \'predict\', \'è¯·é€‰æ‹©é¢„æµ‹ç±»åž‹ï¼š\');\n}\n\nasync function handleCallbackQuery(ctx) {\n    const { callback_query: cq } = ctx.payload;\n    const [action, data] = cq.data.split(\':\');\n    await ctx.bot.answerCallback(cq.id);\n    const chatId = cq.message.chat.id;\n    const msgId = cq.message.message_id;\n\n    if (action === \'sync\') await handleSync(ctx, data, msgId);\n    else if (action === \'view\') { await ctx.bot.deleteMessage(chatId, msgId); await handleView(ctx, data); }\n    else if (action === \'predict\') await handlePredict(ctx, data, msgId);\n    else if (action === \'delete\') await handleDelete(ctx, data, msgId);\n    else if (action === \'close\') await ctx.bot.deleteMessage(chatId, msgId);\n}\n\nasync function handleSync(ctx, type, msgId) {\n    const { bot, db, env } = ctx;\n    const chatId = ctx.payload.callback_query.message.chat.id;\n    const url = getLotteryUrl(type, env);\n    if (!url) return bot.editMessageText(chatId, msgId, \'âŒ å˜é‡ LOTTERY_URLS é…ç½®é”™è¯¯\');\n\n    try {\n        await bot.editMessageText(chatId, msgId, `â³ æ­£åœ¨ä»ŽæºåŒæ­¥ ${LOTTERY_TYPES[type]}...`);\n        const res = await fetch(url);\n        const { data } = await res.json();\n\n        for (const record of data) {\n            const sn = getSpecialNumber(record.openCode);\n            if (sn) {\n                const zodiacs = record.zodiac ? record.zodiac.split(\',\') : [];\n                record.zodiac = zodiacs.length > 0 ? zodiacs.join(\', \') : getZodiac(sn, true);\n\n                const waves = record.wave ? record.wave.split(\',\') : [];\n                const mappedWaves = waves.map(w => WAVE_MAP[w.trim().toLowerCase()] || w.trim());\n                record.wave = mappedWaves.length > 0 ? mappedWaves.join(\', \') : getWave(sn);\n            }\n            await db.addRecord(type, record);\n        }\n        await bot.editMessageText(chatId, msgId, `âœ… ${LOTTERY_TYPES[type]} åŒæ­¥å¹¶è§„èŒƒåŒ–å®Œæˆï¼`);\n    } catch (e) {\n        await bot.editMessageText(chatId, msgId, `âŒ åŒæ­¥å¤±è´¥: ${e.message}`);\n    }\n}\n\n/**\n * æ ¸å¿ƒå‡½æ•°ï¼šå¤„ç†é¢„æµ‹è¯·æ±‚ (å·²å‡çº§)\n */\nasync function handlePredict(ctx, type, msgId) {\n    const { bot, db } = ctx;\n    const chatId = ctx.payload.callback_query.message.chat.id;\n\n    try {\n        await bot.editMessageText(chatId, msgId, `â³ æ­£åœ¨ä¸º ${LOTTERY_TYPES[type]} æ‰§è¡Œé«˜çº§åˆ†æž...`);\n        const records = await db.getRecords(type, 100); // èŽ·å–æœ€è¿‘100æœŸæ•°æ®ç”¨äºŽåˆ†æž\n\n        const prediction = generatePrediction(records);\n\n        if (prediction.error) {\n            return bot.editMessageText(chatId, msgId, `âš ï¸ åˆ†æžä¸­æ­¢: ${prediction.error}`);\n        }\n\n        // å°†æ–°é¢„æµ‹å­˜å…¥æ•°æ®åº“\n        await db.addPrediction(type, prediction);\n        \n        // æ ¼å¼åŒ–è¾“å‡º\n        const text = formatPredictionText(prediction, LOTTERY_TYPES[type]);\n        await bot.editMessageText(chatId, msgId, text);\n\n    } catch (e) {\n        await bot.editMessageText(chatId, msgId, `âŒ é¢„æµ‹å¤±è´¥: ${e.message}\\n${e.stack}`);\n    }\n}\n\n/**\n * æ–°å¢žï¼šæ ¼å¼åŒ–V2é¢„æµ‹æŠ¥å‘Šä¸ºMarkdownæ–‡æœ¬\n */\nfunction formatPredictionText(p, typeName) {\n    return `\n*ðŸ”® ${typeName} é«˜çº§é¢„æµ‹æŠ¥å‘Š ðŸ”®*\n----------------------------------------\n*æ ¸å¿ƒæŽ¨è (ç»¼åˆåŠ æƒ)*\n- *ä¸»æ”»ç”Ÿè‚– (6è‚–)*: ${p.recommendations.combinedZodiacs.join(\', \')}\n- *å¤§èŒƒå›´å·ç  (18ç )*: ${p.recommendations.combinedNumbers.join(\', \')}\n\n*æ•°æ®æ´žå¯Ÿ (ä»…ä¾›å‚è€ƒ)*\n- *è¿‘æœŸçƒ­ç‚¹*: ${p.analysisDetails.hotZodiacs.slice(0, 5).join(\', \')}\n- *å›žå½’é¢„è­¦ (å†·è‚–)*: ${p.analysisDetails.coldZodiacs.slice(0, 5).join(\', \')}\n- *é—æ¼å† å†› (æœ€ä¹…æœªå‡º)*: ${p.analysisDetails.mostOverdueZodiacs.slice(0, 5).join(\', \')}\n- *è·Ÿéšæ¦‚çŽ‡*: \`${p.analysisDetails.transitionFromLast}\`\n\n*åŸºäºŽæœ€è¿‘ ${p.basedOnRecords} æœŸæ•°æ®ç”Ÿæˆ*            \n    `;\n}\n\n\nasync function handleView(ctx, type) {\n    const chatId = ctx.payload.callback_query.message.chat.id;\n    const records = await ctx.db.getRecords(type, 5);\n    for (const r of records) {\n        const text = `ç±»åž‹: ${LOTTERY_TYPES[type]}\\næœŸæ•°: ${r.expect}\\nå·ç : ${r.openCode}\\nç”Ÿè‚–: ${r.zodiac}\\næ³¢è‰²: ${r.wave}`;\n        await ctx.bot.sendMessage(chatId, text, { inline_keyboard: [[{ text: \'ðŸ—‘ï¸ åˆ é™¤\', callback_data: `delete:${r.id}` }]] });\n    }\n}\n\nasync function handleDelete(ctx, id, msgId) {\n    const chatId = ctx.payload.callback_query.message.chat.id;\n    await ctx.db.deleteRecord(id);\n    await ctx.bot.editMessageText(chatId, msgId, `âœ… è®°å½• ${id} å·²åˆ é™¤`);\n}\n\nfunction sendLotterySelection(bot, chatId, prefix, text) {\n    const kb = Object.entries(LOTTERY_TYPES).map(([t, n]) => ({ text: n, callback_data: `${prefix}:${t}` }));\n    const grid = []; for (let i = 0; i < kb.length; i += 2) grid.push(kb.slice(i, i + 2));\n    grid.push([{ text: \'âŒ å…³é—­\', callback_data: \'close:menu\' }]);\n    return bot.sendMessage(chatId, text, { inline_keyboard: grid });\n}\n\nfunction getLotteryUrl(type, env) {\n    try {\n        const urls = JSON.parse(env.LOTTERY_URLS);\n        return urls[type] ? urls[type].replace(/\\b\\d{4}\\b/g, new Date().getFullYear()) : null;\n    } catch (e) { return null; }\n}\n