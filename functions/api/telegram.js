/**\n * =================================================================================\n * Telegram Bot API å…¥å£ & æ ¸å¿ƒäº¤äº’é€»è¾‘ V3.0\n * =================================================================================\n * å˜æ›´æ—¥å¿—:\n * - V3.0: å…¨é¢é‡æž„ï¼Œä¸Žé‡å†™åŽçš„ DB/Logic å±‚å®Œå…¨é›†æˆã€‚\n * - V3.0: æ–°å¢ž \"æŸ¥çœ‹æœ€æ–°é¢„æµ‹\" åŠŸèƒ½ï¼Œä¸Ž \"ç”Ÿæˆæ–°é¢„æµ‹\" åˆ†ç¦»ï¼Œä¼˜åŒ–ç”¨æˆ·ä½“éªŒã€‚\n * - V3.0: å¼ºåŒ–æ•°æ®åŒæ­¥é€»è¾‘ï¼Œå¼ºåˆ¶å¯¹å…¥åº“æ•°æ®è¿›è¡Œæ¸…æ´—å’Œæ ‡å‡†åŒ–ã€‚\n * - V3.0: å…¨é¢é‡‡ç”¨å‚æ•°åŒ–æŸ¥è¯¢å’Œè¯¦ç»†çš„é”™è¯¯å¤„ç†ï¼Œæå‡å¥å£®æ€§ã€‚\n * =================================================================================\n */\n\nimport { LotteryDB } from \'../db/d1-database.js\';\nimport { generatePrediction } from \'../logic/prediction.js\';\nimport { getSpecialNumber, getZodiac, getWave, WAVE_TRANSLATION_MAP } from \'../logic/utils.js\';\n\n// --- Bot UI å®šä¹‰ ---\nconst MAIN_KEYBOARD = [\n    [{ text: \'ðŸ”„ åŒæ­¥æ•°æ®\' }],\n    [{ text: \'ðŸ—‚ï¸ æŸ¥çœ‹è®°å½•\' }, { text: \'ðŸ“ˆ æŸ¥çœ‹é¢„æµ‹\' }],\n    [{ text: \'ðŸ”® ç”Ÿæˆæ–°é¢„æµ‹\' }]\n];\nconst LOTTERY_TYPES = { \'HK\': \'é¦™æ¸¯\', \'XINAO\': \'æ–°æ¾³\', \'LAOAO\': \'è€æ¾³\' };\n\n// --- Bot API å°è£… ---\nclass Bot {\n    constructor(token) { this.token = token; }\n    async apiCall(method, payload) {\n        const resp = await fetch(`https://api.telegram.org/bot${this.token}/${method}`, { \n            method: \'POST\', \n            headers: { \'Content-Type\': \'application/json\' }, \n            body: JSON.stringify(payload) \n        });\n        const json = await resp.json();\n        if (!json.ok) console.error(`Telegram API Error [${method}]:`, json.description);\n        return json;\n    }\n    sendMessage(chat, text, markup = {}) { return this.apiCall(\'sendMessage\', { chat_id: chat, text, ...markup, parse_mode: \'Markdown\' }); }\n    editMessageText(chat, msgId, text, markup = {}) { return this.apiCall(\'editMessageText\', { chat_id: chat, message_id: msgId, text, ...markup, parse_mode: \'Markdown\' }); }\n    deleteMessage(chat, msgId) { return this.apiCall(\'deleteMessage\', { chat_id: chat, message_id: msgId }); }\n    answerCallback(id, text = null) { return this.apiCall(\'answerCallbackQuery\', { callback_query_id: id, text }); }\n}\n\n// --- Cloudflare Worker å…¥å£ ---\nexport const onRequestPost = async ({ request, env }) => {\n    const payload = await request.json();\n    const chatId = payload.message?.chat.id || payload.callback_query?.message.chat.id;\n    if (!chatId || chatId.toString() !== env.TELEGRAM_ADMIN_ID) return new Response(\'Unauthorized\', { status: 403 });\n\n    const context = { db: new LotteryDB(env.DB), bot: new Bot(env.TELEGRAM_BOT_TOKEN), env, payload };\n\n    try {\n        if (payload.message?.text) await handleTextMessage(context);\n        else if (payload.callback_query) await handleCallbackQuery(context);\n    } catch (e) {\n        console.error(\"Unhandled exception in handler:\", e);\n        if (chatId) await context.bot.sendMessage(chatId, `ðŸš¨ *ä¸¥é‡é”™è¯¯* ðŸš¨\\\\nå¤„ç†æ‚¨çš„è¯·æ±‚æ—¶å‘ç”Ÿæ„å¤–çŠ¶å†µã€‚è¯·æ£€æŸ¥åŽå°æ—¥å¿—ã€‚\\\\né”™è¯¯: \`${e.message}\``);\n    }\n\n    return new Response(\'OK\');\n};\n\n// --- å¤„ç†å™¨ ---\nasync function handleTextMessage({ bot, payload }) {\n    const text = payload.message.text.trim();\n    const chat = payload.message.chat.id;\n    if (text === \'/start\') await bot.sendMessage(chat, \'æ‚¨å¥½ï¼è¯·é€‰æ‹©æ“ä½œï¼š\', { reply_markup: { keyboard: MAIN_KEYBOARD, resize_keyboard: true } });\n    else if (text.includes(\'åŒæ­¥\')) await sendLotterySelection(bot, chat, \'sync\', \'è¯·é€‰æ‹©è¦åŒæ­¥çš„ç±»åž‹ï¼š\');\n    else if (text.includes(\'æŸ¥çœ‹è®°å½•\')) await sendLotterySelection(bot, chat, \'view\', \'è¯·é€‰æ‹©è¦æŸ¥çœ‹çš„ç±»åž‹ï¼š\');\n    else if (text.includes(\'æŸ¥çœ‹é¢„æµ‹\')) await sendLotterySelection(bot, chat, \'view_pred\', \'è¯·é€‰æ‹©è¦æŸ¥çœ‹çš„é¢„æµ‹ç±»åž‹ï¼š\');\n    else if (text.includes(\'ç”Ÿæˆæ–°é¢„æµ‹\')) await sendLotterySelection(bot, chat, \'gen_pred\', \'è¯·é€‰æ‹©è¦ç”Ÿæˆé¢„æµ‹çš„ç±»åž‹ï¼š\');\n}\n\nasync function handleCallbackQuery(ctx) {\n    const cq = ctx.payload.callback_query;\n    const [action, data] = cq.data.split(\':\');\n    const chat = cq.message.chat.id;\n    const msgId = cq.message.message_id;\n\n    await ctx.bot.answerCallback(cq.id);\n\n    const handlers = {\n        sync: handleSync,\n        view: async (c, d) => { await c.bot.deleteMessage(chat, msgId); await handleView(c, d); },\n        gen_pred: handleGeneratePrediction,\n        view_pred: handleViewPrediction,\n        delete: handleDelete,\n        close: (c, d) => c.bot.deleteMessage(chat, msgId),\n    };\n\n    if (handlers[action]) await handlers[action](ctx, data, msgId);\n}\n\n// --- æ ¸å¿ƒåŠŸèƒ½å®žçŽ° ---\nasync function handleSync({ bot, db, env }, type, msgId) {\n    const url = getLotteryUrl(type, env);\n    if (!url) return bot.editMessageText(msgId, `âŒ çŽ¯å¢ƒå˜é‡ LOTTERY_URLS é…ç½®é”™è¯¯ã€‚`);\n    \n    await bot.editMessageText(chat, msgId, `â³ æ­£åœ¨ä»ŽæºåŒæ­¥ *${LOTTERY_TYPES[type]}*...`);\n    try {\n        const response = await fetch(url);\n        const { data } = await response.json();\n        let successCount = 0;\n\n        for (const record of data) {\n            const specialNum = getSpecialNumber(record.openCode);\n            if (specialNum) { // åªå¤„ç†åŒ…å«æœ‰æ•ˆç‰¹ç çš„è®°å½•\n                // å¼ºåˆ¶è§„èŒƒåŒ–æ•°æ®\n                record.zodiac = (record.zodiac || getZodiac(specialNum) || \'\').split(\',\').map(z => z.trim()).join(\', \');\n                record.wave = getWave(specialNum);\n                await db.addRecord(type, record);\n                successCount++;\n            }\n        }\n        await bot.editMessageText(chat, msgId, `âœ… *${LOTTERY_TYPES[type]}* åŒæ­¥å®Œæˆï¼\\\\næˆåŠŸå¤„ç†å¹¶å­˜å‚¨äº† ${successCount} / ${data.length} æ¡è®°å½•ã€‚`);\n    } catch (e) {\n        await bot.editMessageText(chat, msgId, `âŒ åŒæ­¥å¤±è´¥: \`${e.message}\``);\n    }\n}\n\nasync function handleGeneratePrediction({ bot, db }, type, msgId) {\n    await bot.editMessageText(chat, msgId, `â³ æ­£åœ¨ä¸º *${LOTTERY_TYPES[type]}* æ‰§è¡Œå…¨æ–°é«˜çº§åˆ†æž...`);\n    try {\n        const records = await db.getRecords(type, 100);\n        const prediction = generatePrediction(records);\n\n        if (prediction.error) {\n            return bot.editMessageText(chat, msgId, `âš ï¸ *åˆ†æžä¸­æ­¢*: ${prediction.error}`);\n        }\n\n        await db.addPrediction(type, prediction);\n        const text = formatPredictionText(prediction, LOTTERY_TYPES[type]);\n        await bot.editMessageText(chat, msgId, text);\n    } catch (e) {\n        await bot.editMessageText(chat, msgId, `âŒ é¢„æµ‹ç”Ÿæˆå¤±è´¥: \`${e.message}\``);\n    }\n}\n\nasync function handleViewPrediction({ bot, db }, type, msgId) {\n    await bot.editMessageText(chat, msgId, `â³ æ­£åœ¨æŸ¥è¯¢ *${LOTTERY_TYPES[type]}* çš„æœ€æ–°é¢„æµ‹...`);\n    try {\n        const latest = await db.getLatestPrediction(type);\n        if (!latest) {\n            return bot.editMessageText(chat, msgId, `â„¹ï¸ æœªæ‰¾åˆ° *${LOTTERY_TYPES[type]}* çš„ä»»ä½•é¢„æµ‹è®°å½•ã€‚è¯·å…ˆç”Ÿæˆä¸€ä¸ªã€‚`);\n        }\n        const text = formatPredictionText(latest.predictionData, LOTTERY_TYPES[type], latest.createdAt);\n        await bot.editMessageText(chat, msgId, text);\n    } catch (e) {\n        await bot.editMessageText(chat, msgId, `âŒ é¢„æµ‹æŸ¥è¯¢å¤±è´¥: \`${e.message}\``);\n    }\n}\n\nasync function handleView({ bot, db }, type) {\n    const records = await db.getRecords(type, 5);\n    if (records.length === 0) return bot.sendMessage(chat, `â„¹ï¸ *${LOTTERY_TYPES[type]}* æ²¡æœ‰ä»»ä½•å¼€å¥–è®°å½•ã€‚`);\n    for (const r of records) {\n        const text = `*ç±»åž‹*: ${LOTTERY_TYPES[type]}\\n*æœŸæ•°*: \`${r.expect}\`\\n*å·ç *: \`${r.openCode}\`\\n*ç”Ÿè‚–*: ${r.zodiac || \'N/A\'}\\n*æ³¢è‰²*: ${r.wave || \'N/A\'}`;\n        await bot.sendMessage(chat, text, { reply_markup: { inline_keyboard: [[{ text: \'ðŸ—‘ï¸ åˆ é™¤\', callback_data: `delete:${r.id}` }]] }});\n    }\n}\n\nasync function handleDelete({ bot, db }, id, msgId) {\n    await db.deleteRecord(id);\n    await bot.editMessageText(chat, msgId, `âœ… è®°å½•(ID: ${id}) å·²è¢«åˆ é™¤ã€‚`);\n}\n\n// --- è¾…åŠ©å‡½æ•° ---\nfunction sendLotterySelection(bot, chat, prefix, text) {\n    const keyboard = Object.entries(LOTTERY_TYPES).map(([type, name]) => ({ text: name, callback_data: `${prefix}:${type}` }));\n    const grid = []; for (let i = 0; i < keyboard.length; i += 2) grid.push(keyboard.slice(i, i + 2));\n    grid.push([{ text: \'âŒ å…³é—­\', callback_data: \'close:menu\' }]);\n    return bot.sendMessage(chat, text, { reply_markup: { inline_keyboard: grid } });\n}\n\nfunction getLotteryUrl(type, env) {\n    try {\n        const urls = JSON.parse(env.LOTTERY_URLS);\n        return urls[type] ? urls[type].replace(/\\b\\d{4}\\b/g, new Date().getFullYear()) : null;\n    } catch (e) { console.error(\"Failed to parse LOTTERY_URLS env var:\", e); return null; }\n}\n\nfunction formatPredictionText(p, typeName, createdAt = null) {\n    const date = createdAt ? new Date(createdAt) : new Date(p.generatedAt);\n    const localDate = date.toLocaleString(\'zh-CN\', { timeZone: \'Asia/Shanghai\', hour12: false });\n    const title = createdAt ? `ðŸ“œ ${typeName} æœ€æ–°é¢„æµ‹æŠ¥å‘Š ðŸ“œ` : `ðŸ”® ${typeName} å…¨æ–°é¢„æµ‹æŠ¥å‘Š ðŸ”®`;\n\n    return `\n*${title}*\n*ç”Ÿæˆæ—¶é—´*: \`${localDate}\`\n----------------------------------------\n*æ ¸å¿ƒæŽ¨è (ç»¼åˆåŠ æƒ)*\n- *ä¸»æ”»ç”Ÿè‚– (6è‚–)*: ${p.recommendations.combinedZodiacs.join(\', \')}\n- *å¤§èŒƒå›´å·ç  (18ç )*: \`${p.recommendations.combinedNumbers.join(\', \')}\`\n\n*æ•°æ®æ´žå¯Ÿ (ä»…ä¾›å‚è€ƒ)*\n- *è¿‘æœŸçƒ­ç‚¹*: ${p.analysisDetails.hotZodiacs.join(\', \')}\n- *å›žå½’é¢„è­¦ (å†·è‚–)*: ${p.analysisDetails.coldZodiacs.join(\', \')}\n- *é—æ¼å† å†› (æœ€ä¹…æœªå‡º)*: ${p.analysisDetails.mostOverdueZodiacs.join(\', \')}\n- *è·Ÿéšæ¦‚çŽ‡*: \`${p.analysisDetails.transitionFromLast}\`\n\n*åŸºäºŽæœ€è¿‘ ${p.basedOnRecords} æœŸæœ‰æ•ˆæ•°æ®ç”Ÿæˆ*\n    `;\n}\n